\indexentry{mutual exclusion|indexref{1}{principles}{1mutex}}{1}
\indexentry{Dijkstra, Edsger|indexref{1}{principles}{1dijkstra}}{1}
\indexentry{critical section|indexref{1}{principles}{1critical section}}{1}
\indexentry{section!critical|indexref{1}{principles}{1section-critical}}{1}
\indexentry{store|indexref{1}{principles}{1store}}{1}
\indexentry{noncritical section|indexref{1}{principles}{1noncritical section}}{1}
\indexentry{section!noncritical|indexref{1}{principles}{1section-noncritical}}{1}
\indexentry{livelock|indexref{1}{principles}{1livelock}}{1}
\indexentry{deadlock freedom|indexref{1}{principles}{1deadlock freedom}}{1}
\indexentry{dining philosophers problem|indexref{1}{principles}{1dining philosophers problem}}{1}
\indexentry{starvation freedom|indexref{1}{principles}{1starvation freedom}}{1}
\indexentry{One-Bit Protocol|indexref{1}{principles}{1One-Bit Protocol}}{1}
\indexentry{behavioral proof|indexref{1}{principles}{1behavioral proof}}{1}
\indexentry{proof!behavioral|indexref{1}{principles}{1proof-behavioral}}{1}
\indexentry{invariant!inductive|indexref{2}{principles}{2inv-inductive}}{2}
\indexentry{inductive invariant|indexref{2}{principles}{2inductive invariant}}{2}
\indexentry{inductive invariant!checking with TLC|indexref{1}{principles}{1inductive-check-tlc}}{1}
\indexentry{BOOLEAN (TLA+ statement)@{\icmd {textsc}{boolean}} (\icmd {tlaplus} statement)|indexref{1}{principles}{1BOOLEAN}}{1}
\indexentry{either (PlusCal keyword)@\icmd {peither} (PlusCal keyword)|indexref{1}{principles}{1either-pcal}}{1}
\indexentry{or (PlusCal keyword)@\icmd {por} (PlusCal keyword)|indexref{1}{principles}{1or-pcal}}{1}
\indexentry{undefined or not an operator|indexref{1}{principles}{1undefined or not an operator}}{1}
\indexentry{next states, too many|indexref{1}{principles}{1next states, too many}}{1}
\indexentry{largest enumerable set|indexref{1}{principles}{1largest enumerable set}}{1}
\indexentry{TLC!state constraint|indexref{1}{principles}{1tlc-state-constraint}}{1}
\indexentry{state constraint, in TLC|indexref{1}{principles}{1state-constraint}}{1}
\indexentry{constraint, state|indexref{1}{principles}{1constraint-state}}{1}
\indexentry{One-Bit Algorithm!Two-Process|indexref{1}{principles}{1one-bit-2-proc-alg}}{1}
\indexentry{+2rq@\mmath {\icmd {leadsto}} (leads to)|indexref{1}{principles}{1+2rq}}{1}
\indexentry{synchronization primitive|indexref{1}{principles}{1synchronization primitive}}{1}
\indexentry{busy waiting|indexref{1}{principles}{1busy waiting}}{1}
\indexentry{waiting, busy|indexref{1}{principles}{1waiting, busy}}{1}
\indexentry{+2pl@\mmath {-} after PlusCal label|indexref{2}{principles}{2+2pl}}{2}
\indexentry{One-Bit Algorithm!\mmath {N}-Process|indexref{1}{principles}{1one-bit-N-proc-alg}}{1}
\indexentry{bakery algorithm|indexref{1}{principles}{1bakery algorithm}}{1}
\indexentry{Hyman, Harris|indexref{1}{principles}{1Hyman, Harris}}{1}
\indexentry{Knuth, Donald Ervin|indexref{1}{principles}{1Knuth, Donald Ervin}}{1}
\indexentry{big-step bakery algorithm|indexref{1}{principles}{1big-step bakery algorithm}}{1}
\indexentry{lexicographical ordering|indexref{1}{principles}{1lexicographical ordering}}{1}
\indexentry{order!lexicographic|indexref{1}{principles}{1order-lexicographic}}{1}
\indexentry{state constraint|indexref{2}{principles}{2state-constraint}}{2}
\indexentry{constraint, state|indexref{2}{principles}{2constraint-state}}{2}
\indexentry{first-come-first-served|indexref{1}{principles}{1first-come-first-served}}{1}
\indexentry{FCFS|indexref{1}{principles}{1FCFS}}{1}
\indexentry{grain of atomicity|indexref{2}{principles}{2grain of atomicity}}{2}
\indexentry{atomicity!grain of|indexref{2}{principles}{2atomicity-grain}}{2}
\indexentry{elementary data item|indexref{1}{principles}{1elementary data item}}{1}
\indexentry{data item, elementary|indexref{1}{principles}{1data item, elementary}}{1}
\indexentry{single access rule|indexref{1}{principles}{1single access rule}}{1}
\indexentry{atomic bakery algorithm|indexref{1}{principles}{1atomic bakery algorithm}}{1}
\indexentry{bakery algorithm!atomic|indexref{1}{principles}{1bakery-algorithm-atomic}}{1}
\indexentry{mutual exclusion!in modern computers|indexref{1}{principles}{1mutex-modern}}{1}
\indexentry{lock|indexref{1}{principles}{1lock}}{1}
\indexentry{bounded channel|indexref{1}{principles}{1bounded channel}}{1}
\indexentry{FIFO (first in, first out)|indexref{1}{principles}{1FIFO (first in, first out)}}{1}
\indexentry{sequence!finite|indexref{1}{principles}{1seq-finite}}{1}
\indexentry{tuple!same as sequence|indexref{1}{principles}{1tuple-same-as-sequence}}{1}
\indexentry{infinite sequence|indexref{1}{principles}{1infinite sequence}}{1}
\indexentry{sequence!infinite|indexref{1}{principles}{1sequence-infinite}}{1}
\indexentry{observable variable|indexref{1}{principles}{1observable variable}}{1}
\indexentry{variable!observable|indexref{1}{principles}{1variable-observable}}{1}
\indexentry{modular arithmetic|indexref{1}{principles}{1modular arithmetic}}{1}
\indexentry{arithmetic, modular|indexref{1}{principles}{1arithmetic, modular}}{1}
\indexentry{modulus operator|indexref{4}{principles}{4modulus operator}}{4}
\indexentry{+5w@\mmath {\%} (modulus)|indexref{3}{principles}{3+5w}}{3}
\indexentry{+4mf@\mmath {[S\rightarrow T]} (set of functions)|indexref{1}{principles}{1+4mf}}{1}
\indexentry{process|indexref{1}{principles}{1process}}{1}
\indexentry{identity refinement mapping|indexref{1}{principles}{1identity refinement mapping}}{1}
\indexentry{refinement mapping!identity|indexref{1}{principles}{1identity}}{1}
